# 간단한 완전탐색(Simple Brute-Force Algorithm)- 1
* 가능한 모든 경우를 모두 시도해본다.
* ex) 약수의 개수가 홀수인 수  입력:10 출력 :3
* 1-1개o 2-2개 3-2개 4-3개o 5-2개 6-4개 7-2개 8-4개 9-3개o 10-4개 -> 약수의 개수가 홀수인 수 : 3개

-----------------------------------------------------
<img width="500" src="https://user-images.githubusercontent.com/70589857/103610145-c2e35600-4f62-11eb-910c-59f3fd079be3.PNG">
 b[i][j] = a[i][M-j-1] point! 이 코드가 좌우를 바꿔줌
 
 -----------------------------------------------------
 <img width="500" src="https://user-images.githubusercontent.com/70589857/103618662-ae5b8980-4f73-11eb-8deb-9675d105f9b0.PNG">
새로운 2차원 배열 만들고 거기에 입력값 받아서 1,1~5,5에 값 복사하기! 

 -----------------------------------------------------
 ```
 최대공약수
 <유클리드 호제법>
gcd(a,b) = gcd(b,a%b)
ex) gcd(24,18) = gcd(18,6)
while(1) {
 c= a%b
 if(c==0) break;
 a=b;
 b=c;
}
int GCD= b
``` 
